/***************************************************************
 Drainage density (km stream per km^2) for India â€” TILED EXPORT
 Data: MERIT/Hydro/v1_0_1 (uses 'upa' upstream drainage area)
***************************************************************/

// -------------------- USER PARAMETERS -------------------------
var upaThreshold_km2 = 0.05;   // threshold to define stream (km^2). lower => more streams
var windowSize_km = 10;        // square window side (km) to compute density
var exportScale = 1000;        // export resolution in meters (250 native but large)
var exportFolder = 'Drainage'; // Drive folder
var gridSize = 5;              // tiles per side (5 => 25 tiles). Keep <= ~6 for safe getInfo()
// -------------------------------------------------------------

// 1) AOI = India
var aoi = ee.FeatureCollection('FAO/GAUL/2015/level0')
             .filter(ee.Filter.eq('ADM0_NAME', 'India'));
Map.centerObject(aoi, 5);
Map.addLayer(aoi.style({color: '000000', fillColor: '00000000'}), {}, 'India AOI');

// 2) Load MERIT Hydro and preview bands
var merit = ee.Image('MERIT/Hydro/v1_0_1');
print('MERIT bands:', merit.bandNames());
var upa = merit.select('upa'); // upstream drainage area in km^2

// 3) Create stream mask by thresholding upa
var streamMask = upa.gte(upaThreshold_km2).rename('streamMask'); // 1 for stream, 0 otherwise
Map.addLayer(streamMask.updateMask(streamMask).clip(aoi), {palette: ['0000FF']}, 'Stream mask (upa>=' + upaThreshold_km2 + ')');

// 4) Compute stream pixel count in moving window
var windowSize_m = ee.Number(windowSize_km).multiply(1000);
var halfWindow = windowSize_m.divide(2);

// Square kernel in meters
var kernel = ee.Kernel.square({radius: halfWindow, units: 'meters', normalize: false});

// approximate MERIT pixel length (dataset ~92.77 m). We'll use this for converting pixel count to length.
var pixel_length_m = ee.Number(92.77);

// sum of stream pixels inside window
var streamCount = streamMask.reduceNeighborhood({
  reducer: ee.Reducer.sum(),
  kernel: kernel,
  optimization: 'window'
}).rename('stream_count');

// 5) compute drainage density (km stream per km^2)
// length in km = count * pixel_length_m / 1000
// area in km^2 = (windowSize_m^2) / 1e6
var windowArea_m2 = windowSize_m.multiply(windowSize_m);
var density = streamCount.expression(
  '(count * pixel_len_m / 1000) / (windowArea_m2 / 1e6)', {
    'count': streamCount.select('stream_count'),
    'pixel_len_m': pixel_length_m,
    'windowArea_m2': windowArea_m2
  }).rename('drainage_density_km_per_km2');

var densityIndia = density.clip(aoi).updateMask(density.gt(0));
var densVis = {min: 0, max: 2.0, palette: ['ffffff','b3cde3','8c96c6','8856a7','f16913','d94801']};
Map.addLayer(densityIndia, densVis, 'Drainage density (km/km^2)');

// 6) Create tile grid covering India (server-side)
var indiaGeom = aoi.geometry();
var bounds = indiaGeom.bounds();
var coords = ee.List(bounds.coordinates().get(0));

var xmin = ee.Number(ee.List(coords.get(0)).get(0));
var ymin = ee.Number(ee.List(coords.get(0)).get(1));
var xmax = ee.Number(ee.List(coords.get(2)).get(0));
var ymax = ee.Number(ee.List(coords.get(2)).get(1));

var dx = xmax.subtract(xmin).divide(ee.Number(gridSize));
var dy = ymax.subtract(ymin).divide(ee.Number(gridSize));

var iList = ee.List.sequence(0, gridSize - 1);
var jList = ee.List.sequence(0, gridSize - 1);

var tilesFC = ee.FeatureCollection(
  iList.map(function(i) {
    i = ee.Number(i);
    return jList.map(function(j) {
      j = ee.Number(j);
      var x1 = xmin.add(dx.multiply(j));
      var x2 = xmin.add(dx.multiply(j.add(1)));
      var y1 = ymin.add(dy.multiply(i));
      var y2 = ymin.add(dy.multiply(i.add(1)));
      var rect = ee.Geometry.Rectangle([x1, y1, x2, y2], null, false);
      var tile_id = i.multiply(gridSize).add(j); // unique id
      return ee.Feature(rect, {tile_id: tile_id});
    });
  }).flatten()
);

// visualize tiles
Map.addLayer(tilesFC.style({color: 'yellow', fillColor: '00000000'}), {}, 'Export Tiles');

// 7) Convert small tiles list to client for export creation (safe for <= ~50 tiles)
var tilesClient = tilesFC.toList(tilesFC.size()).getInfo();
print('Number of tiles:', tilesClient.length);

// 8) Create one export per tile (drainage density)
for (var k = 0; k < tilesClient.length; k++) {
  var feat = tilesClient[k];
  var id = feat.properties.tile_id;
  var geom = ee.Geometry(feat.geometry);

  Export.image.toDrive({
    image: density.clip(geom).toFloat(),
    description: 'India_DrainageDensity_Tile_' + id,
    fileNamePrefix: 'India_DrainageDensity_Tile_' + id,
    folder: exportFolder,
    region: geom,
    scale: exportScale,
    crs: 'EPSG:4326',
    maxPixels: 1e13
  });
}

// 9) Also export the stream mask per tile (optional)
// Uncomment block below to export stream mask tiles as well:
/*
for (var k2 = 0; k2 < tilesClient.length; k2++) {
  var feat2 = tilesClient[k2];
  var id2 = feat2.properties.tile_id;
  var geom2 = ee.Geometry(feat2.geometry);

  Export.image.toDrive({
    image: streamMask.clip(geom2).toByte(),
    description: 'India_StreamMask_Tile_' + id2,
    fileNamePrefix: 'India_StreamMask_Tile_' + id2,
    folder: exportFolder,
    region: geom2,
    scale: exportScale,
    crs: 'EPSG:4326',
    maxPixels: 1e13
  });
}
*/

// 10) Summary print
print('Parameters:', {
  upaThreshold_km2: upaThreshold_km2,
  windowSize_km: windowSize_km,
  exportScale: exportScale,
  gridSize: gridSize,
  tiles: tilesClient.length
});

////////////////////////////////////////////////////////////////////////////////
// NOTES
// - If any export tasks fail because of size, increase gridSize or increase exportScale.
// - If you need automatic (programmatic) start of tasks (no manual RUN in Tasks tab),
//   use the Earth Engine Python API to start them programmatically. I can provide that.
////////////////////////////////////////////////////////////////////////////////
